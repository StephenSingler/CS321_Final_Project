The first thing that happens is that the BTree writes its metadata to the disk. This contains the degree, the size of BTreeNode, and the offset. There is a variable in BTree that keeps track of the current root, that is incremented everytime something is inserted. When each node is written, the BTree writes that node's metadata, which includes whether or not its a leaf and its number of keys. Each node keeps some data: LinkedList of child pointers (offsets in the file), a LinkedList of TreeObjects, the offset of the parent and its own offset. The BTree writes the node's parent, then alternates between writing child pointer and object. The pointer is written first, then the object (key), then the frequency. Then the second child pointer and so on are written. The BTree writes 0's in unused places. There are a couple scenarios to consider when writing a node, when splitting a node that is a root and splitting a node that isn't a root. The first scenario, we are getting three nodes from one, so we create a new node, move t-1 keys to it, move the medium key up to the new root, move children if the old root wasn't a leaf, then write the nodes. The second scenario, we are only creating one new node. The new node gets the split node's last t-1 keys. The parent of the split node gets its medium key, and we move children if necessary, then write.
